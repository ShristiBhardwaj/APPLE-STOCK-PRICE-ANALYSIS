# -*- coding: utf-8 -*-
"""Shristi_Bhardwaj_Apple_Stock.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1zyMq9hp09u2H_cr_TNTN5ZxMLhkifbmk

# **APPLE STOCK PRICE PREDICTION**

## **Problem Statement**:


Analyzing Historical Trends and Predicting Future Performance of Apple Inc. Stock

**IMPORT THE LIBRARIES**
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score

"""## **LOADING THE DATASET**"""

df=pd.read_csv('/Apple_stock_data_assignment.csv')

"""## **UNDERSTANDING THE DATASET**"""

df.head()

df.tail()

df.shape

df.info()

df.describe()

df.columns

"""**ATTRIBUTE** **INFORMATION**:

* **symbol**: A short code representing the stock, in this case, 'AAPL' for Apple Inc.

* **date**: The specific date when the stock data was recorded.

* **close**: The price of Apple's stock at the end of the trading day.

* **high**: The highest price at which Apple's stock was traded during the day.

* **low**: The lowest price at which Apple's stock was traded during the day.

* **open**: The price of Apple's stock at the beginning of the trading day.

* **volume**: The total number of shares of Apple stock that were traded during the day.

* **adjClose**: The closing price of Apple's stock adjusted for any actions like splits or dividends to provide a consistent comparison over time.

* **adjHigh**: The highest price of Apple's stock adjusted for splits or dividends.

* **adjLow**: The lowest price of Apple's stock adjusted for splits or dividends.

* **adjOpen**: The opening price of Apple's stock adjusted for splits or dividends.

* **adjVolume**: The total number of shares traded, adjusted for splits or dividends.

* **divCash**: The amount of dividend cash paid per share.

* **splitFactor**: The ratio by which the stock has been split. For example, a 2-for-1 split would have a split factor of 2.

**DATA CLEANING**
"""

# Check for missing values in each column
df.isnull().sum()

"""**THERE ARE NO MISSING VALUES**"""

# Check for and remove any duplicate rows
df = df.drop_duplicates()

#Converting date to datetime format
df['date'] = pd.to_datetime(df['date'])

df.info()

"""## **VISUALIZING THE DATA**"""

plt.figure(figsize=(10, 6))
plt.plot(df['date'], df['close'], label='Close Price')
plt.plot(df['date'], df['adjClose'], label='Adjusted Close Price', linestyle='--')
plt.xlabel('Date')
plt.ylabel('Price')
plt.title('Stock Closing Prices Over Time')
plt.legend()
plt.show()

""" **Conclusion**: The time series plot of the close price shows the trend of Apple's stock price over time.

 It reveals periods of growth, stability, and volatility, helping to understand the stock's historical performance.



"""

# Distribution of Close Prices
plt.figure(figsize=(10, 5))
sns.histplot(df['close'], bins=50, kde=True,color='orange')
plt.title('Distribution of Close Prices')
plt.xlabel('Close Price ($)')
plt.ylabel('Frequency')
plt.show()

""" **Conclusion**: The histogram and KDE plot show the distribution of close prices, revealing the most common price ranges and the overall spread of prices. It helps in understanding the stock's price volatility."""

# Box Plot for Close Prices
plt.figure(figsize=(10, 5))
sns.boxplot(x=df['close'],color='red')
plt.title('Box Plot of Close Prices')
plt.xlabel('Close Price ($)')
plt.show()

""" **Conclusion**: The box plot highlights the distribution of close prices, including the median, quartiles, and outliers.
Identifying the range within which most of the stock prices fall and any potential outliers.
We see the most close price between 150 and 200$
"""

# Volume Over Time
plt.figure(figsize=(14, 7))
plt.plot(df['volume'], label='Volume', color='teal')
plt.title('Apple Trading Volume Over Time')
plt.xlabel('Date')
plt.ylabel('Volume')
plt.legend()
plt.show()

""" **Conclusion**: The volume plot shows the trading activity over time.
 We see a peak in trading activity between 200 and 400 days
"""

#To visualize the correlation between different financial metrics.
plt.figure(figsize=(10, 6))
sns.heatmap(df[['close', 'high', 'low', 'open', 'volume', 'adjClose', 'adjHigh', 'adjLow', 'adjOpen', 'adjVolume']].corr(), annot=True, cmap='summer')
plt.title('Correlation Heatmap')
plt.show()

"""**Conclusion:**There is a high correlation between columns like close,high,open,low and a negative(inverse) relation between adjopen,high,adjopen,open,etc

## **SCALING TECHINIQUE:**
"""

from sklearn.preprocessing import StandardScaler

# Selecting numerical columns for scaling
columns_to_scale = ['close', 'high', 'low', 'open', 'volume', 'adjClose', 'adjHigh', 'adjLow', 'adjOpen', 'adjVolume', 'divCash', 'splitFactor']

# Initialize StandardScaler
scaler = StandardScaler()

# Fit scaler on the data and transform it
df[columns_to_scale] = scaler.fit_transform(df[columns_to_scale])

"""**Conclusion:**
* StandardScaler from sklearn.preprocessing is used to standardize the numerical columns.
* fit_transform() method is used to fit the scaler on the data and transform it in one step.
* This standardizes each feature (column) to have a mean of 0 and a standard deviation of 1.
"""

df

df.isnull().sum()

df

"""## **MODEL TRAINING**"""

# Drop non-numeric columns if not needed for the model
df = df.drop(columns=['symbol', 'date'])

# Define features and target variable
x = df.drop(columns=['close'])  # Features (excluding target)
y = df['close']  # Target variable

x

y.head()

"""### **Splitting the data into training and testing sets**"""

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3, random_state=42)

x_train

x_train.shape

x_test

x_test.shape

y_train.head()

y_train.shape

y_test.head()

y_test.shape

"""## **1. LINEAR REGRESSION**"""

# Initialize the model
model = LinearRegression()

# Train the model
model.fit(x_train, y_train)

# Predict on the test set
y_pred_reg = model.predict(x_test)

y_pred_reg.shape

"""**EVALUATE THE MODEL**"""

# Evaluate the model
mse = mean_squared_error(y_test, y_pred_reg)
r2 = r2_score(y_test, y_pred_reg)

print(f"Mean Squared Error: {mse}")
print(f"R^2 Score: {r2}")

"""## **2. DECISION TREE**"""

from sklearn.tree import DecisionTreeRegressor, plot_tree

# Initialize the model
model1 = DecisionTreeRegressor(max_depth=5)

# Train the model
model1.fit(x_train, y_train)

# Predict on the test set
pred_y_dt = model1.predict(x_test)

pred_y_dt

# Evaluate the model
mse = mean_squared_error(y_test, pred_y_dt)
r2 = r2_score(y_test, pred_y_dt)

print(f"Mean Squared Error: {mse}")
print(f"R^2 Score: {r2}")

# Plot the decision tree
plt.figure(figsize=(20, 10))  # Adjust size as needed
plot_tree(model1, filled=True, feature_names=x.columns, rounded=True)
plt.title('Decision Tree Visualization')
plt.show()

"""## **3. RANDOM FOREST**"""

from sklearn.ensemble import RandomForestRegressor

# Initialize the model
model2 = RandomForestRegressor(n_estimators=100, random_state=42)

# Train the model
model2.fit(x_train, y_train)

# Predict on the test set
y_predict_rf = model2.predict(x_test)

y_predict_rf

# Evaluate the model
mse = mean_squared_error(y_test, y_predict_rf)
r2 = r2_score(y_test, y_predict_rf)

print(f"Mean Squared Error: {mse}")
print(f"R^2 Score: {r2}")